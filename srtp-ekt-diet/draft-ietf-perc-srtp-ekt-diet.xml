<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc5226 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY rfc6347 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY rfc6407 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6407.xml">
<!ENTITY rfc5234 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY rfc2675 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2675.xml">
<!ENTITY rfc4301 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml">
<!ENTITY rfc2409 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2409.xml">
<!ENTITY rfc2410 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2410.xml">
<!ENTITY rfc2406 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2406.xml">
<!ENTITY rfc2407 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2407.xml">
<!ENTITY rfc3261 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY rfc3264 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY rfc5649 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5649.xml">
<!ENTITY rfc4648 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY rfc3550 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY rfc3610 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3610.xml">
<!ENTITY rfc3602 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3602.xml">
<!ENTITY rfc3686 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3686.xml">
<!ENTITY rfc3830 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml">
<!ENTITY rfc3711 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
<!ENTITY rfc4563 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4563.xml">
<!ENTITY rfc4771 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4771.xml">
<!ENTITY rfc4567 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4567.xml">
<!ENTITY rfc4568 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4568.xml">
<!ENTITY rfc5764 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5764.xml">
<!ENTITY rfc4566 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY rfc4086 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
<!ENTITY rfc4366 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4366.xml">
<!ENTITY rfc5246 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc5234 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<rfc category="std" docName="draft-ietf-perc-srtp-ekt-diet-02" ipr="trust200902">

  <front>
    <title abbrev="EKT SRTP">Encrypted Key Transport for Secure RTP</title>

    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization abbrev="Cisco">Cisco Systems</organization>
      
      <address>
        <postal>
        <street></street>

          <city>Calgary</city>

          <region>AB</region>

          <code></code>

          <country>Canada</country>
       </postal>

        <email>fluffy@iii.ca</email>
      </address>
    </author>


    <author fullname="John Mattsson" initials="J.M" surname="Mattsson" role="editor" >
      <organization abbrev="Ericsson">Ericsson AB</organization>

      <address>
        <postal>
          <street>SE-164 80 Stockholm</street>

          <country>Sweden</country>
        </postal>

        <phone>+46 10 71 43 501</phone>

        <email>john.mattsson@ericsson.com</email>
      </address>
    </author>


    <author fullname="David A. McGrew" initials="D.A.M." surname="McGrew">
      <organization abbrev="Cisco">Cisco Systems</organization>

      <address>
        <postal>
          <street>510 McCarthy Blvd.</street>

          <city>Milpitas</city>

          <region>CA</region>

          <code>95035</code>

          <country>US</country>
        </postal>

        <phone>(408) 525 8651</phone>

        <email>mcgrew@cisco.com</email>

        <uri>http://www.mindspring.com/~dmcgrew/dam.htm</uri>
      </address>
    </author>


    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Cisco">Cisco Systems</organization>

      <address>
        <postal>
          <street>510 McCarthy Blvd.</street>

          <city>Milpitas</city>

          <region>CA</region>

          <code>95035</code>

          <country>US</country>
        </postal>

        <phone>(408) 853 4197</phone>

        <email>dwing@cisco.com</email>
      </address>
    </author>


    <author fullname="Flemming Andreason" initials="F.A." surname="Andreasen">
      <organization abbrev="Cisco">Cisco Systems</organization>

      <address>
        <postal>
          <street>499 Thornall Street</street>

          <city>Edison</city>

          <region>NJ</region>

          <code>08837</code>

          <country>US</country>
       </postal>

        <email>fandreas@cisco.com</email>
      </address>
    </author>

      <date month="October" day="31" year="2016"/>


    <area>ART</area>

    <workgroup>PERC Working Group</workgroup>

    <keyword>RTP</keyword>

    <keyword>SRTP</keyword>

    <keyword>EKT</keyword>

    <abstract>
      
      <t>Encrypted Key Transport (EKT) is an extension to Secure
      Real-time Transport Protocol (SRTP) that provides for the secure
      transport of SRTP master keys, rollover counters, and other
      information within SRTP.  This facility enables SRTP for
      decentralized conferences by distributing a common key to all of
      the conference endpoints.
      </t>

    </abstract>
    
  </front>

  <middle>
    <section title="Introduction">
      
      <t>Real-time Transport Protocol (RTP) is designed to allow 
      decentralized groups with minimal control to
      establish sessions, such as for multimedia conferences.  Unfortunately,
      Secure RTP (<xref target="RFC3711">SRTP</xref>) cannot be used in many
      minimal-control scenarios, because it requires that
      synchronization source (SSRC) values and other
      data be coordinated among all of the participants in a session.  For
      example, if a participant joins a session that is already in progress,
      that participant needs to be told the SRTP keys along with the SSRC, roll
      over counter (ROC) and other
      details of the other SRTP sources.</t>

      <t>The inability of SRTP to work in the absence of central control was
      well understood during the design of the protocol; the omission was
      considered less important than optimizations such as bandwidth
      conservation. Additionally, in many situations SRTP is used in conjunction
      with a signaling system that can provide the central control
      needed by SRTP. However, there are several cases in which conventional
      signaling systems cannot easily provide all of the coordination
      required. It is also desirable to eliminate the layer violations that
      occur when signaling systems coordinate certain SRTP parameters, such as
      SSRC values and ROCs.</t>

      <t>This document defines Encrypted Key Transport (EKT) for SRTP and
      reduces the amount of external signaling control that is needed in a SRTP
      session with multiple receivers. EKT securely distributes
      the SRTP master key and other information for each SRTP source. With this
      method, SRTP entities are free to choose SSRC values as they see fit, and
      to start up new SRTP sources with new SRTP master keys (see Section
      2.2) within a session without coordinating with other entities via
      external signaling or other external means. </t>

      <t>EKT provides a way for an SRTP session participant, either a sender or
      receiver, to securely transport its SRTP master key and current SRTP
      rollover counter to the other participants in the session.  This data
      furnishes the information needed by the receiver to
      instantiate an SRTP/SRTCP receiver context.</t>

      <t>EKT does not control the manner in which the SSRC is generated; it is
      only concerned with their secure transport. </t>

      <t>EKT is not intended to replace external key establishment mechanisms.
      Instead, it is used in conjunction with those methods, and it 
      relieves those methods of the burden to deliver the 
      context for each SRTP source to every SRTP participant.
      </t>

      <section title="Conventions Used In This Document">

        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"></xref>.</t>

      </section>
    </section>

    <section anchor="normative" title="Encrypted Key Transport">
      
      <t>EKT defines a new method of providing SRTP master keys to an endpoint.
      In order to convey the ciphertext of the SRTP master key, and other
      additional information, an additional EKT field is added to SRTP packets.
      When added to SRTP, the EKT field appears at the end of the SRTP packet,
      after the authentication tag (if that tag is present), or after the
      ciphertext of the encrypted portion of the packet otherwise.</t>

      <t>EKT MUST NOT be used in conjunction with SRTP's MKI (Master Key
      Identifier) or with SRTP's &lt;From, To&gt; <xref
      target="RFC3711"></xref>, as those SRTP features duplicate some of the
      functions of EKT.
      </t>

      <section anchor="EKT" title="EKT Field Formats">
        
        <t> The EKT Field uses the format defined below for the FullEKTField
        and ShortEKTField.  </t>

       <figure anchor="tag_format_base"
                title="Full EKT Field format"
              align="center">
          <artwork align="center">
           <![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:                                                               :
:                        EKT Ciphertext                         :
:                                                               :
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Security Parameter Index  |   Length                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 1 0|
+-+-+-+-+-+-+-+-+
]]></artwork>

       </figure>
       
        <figure anchor="tag_format_abbreviated"
                title="Short EKT Field format"
              align="center">
          <artwork align="center"><![CDATA[
 0 1 2 3 4 5 6 7 
+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 0 0|
+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

        <t> The following shows the syntax of for the EKTField
        expressed in ABNF <xref target="RFC5234"/>. The EKTField is
        added to end of an SRTP or SRTCP packet. The EKTCiphertext is
        computed by encrypting the EKTPlaintext using the
        EKTKey. Future extensions to the EKTField MUST to conform to
        the syntax of ExtensionEKTField. </t>
        
        <figure anchor="tag_formats"
                title="EKTField Syntax">
<artwork align="left"><![CDATA[
BYTE = %x00-FF

EKTMsgTypeFull = %x02 
EKTMsgTypeShort = %x00 
EKTMsgTypeExtension = %x03-FF 

EKTMsgLength = 2BYTE;

SRTPMasterKeyLength = BYTE 
SRTPMasterKey = 1*256BYTE 
SSRC = 4BYTE; SSRC from RTP 
ROC = 4BYTE ; ROC from SRTP

EKTPlaintext = SRTPMasterKeyLength SRTPMasterKey SSRC ROC 

EKTCiphertext = 1*256BYTE ; EKTEncrypt(EKTKey, EKTPlaintext)
SPI = 2BYTE 

FullEKTField = EKTCiphertext SPI EKTMsgLength EKTMsgTypeFull

ShortEKTField = EKTMsgTypeShort

ExtensionData = 1*1024BYTE
ExtensionEKTField = ExtensionData EKTMsgLength EKTMsgTypeExtension

EKTField = FullEKTField / ShortEKTField / ExtensionEKTField
]]></artwork>
        </figure>

        <t>
         
         These fields and data elements are defined
          as follows:
          <list style="hanging">

               <t hangText="EKTPlaintext:">The data that is input to
               the EKT encryption operation.  This data never appears
               on the wire, and is used only in computations internal
               to EKT. This is the concatenation of the SRTP Master
               Key, the SSRC, and the ROC.
               </t>

               <t hangText="EKTCiphertext:">The data that is output from the
               EKT encryption operation, described in <xref
               target="cipher"></xref>.  This field is included in SRTP packets
               when EKT is in use.  
               </t>

               <t hangText="SRTPMasterKey:">On the sender side, the SRTP
               Master Key associated with the indicated SSRC. </t>

                <t hangText="SRTPMasterKeyLength:"> The length of
                the SRTPMasterKey. This depends on the cipher suite
                negotiated for SRTP using <xref target="RFC3264" />
                SDP Offer/Answer for the SRTP.</t>

               <t hangText="SSRC:">On the sender side, this field is the SSRC
               for this SRTP source.  The length of this field is 32 bits.</t>

            <t hangText="Rollover Counter (ROC):">On the sender side, this field
            is set to the current value of the SRTP rollover counter in the SRTP
            context associated with the SSRC in the SRTP or SRTCP packet.  The
            length of this field is 32 bits.
            </t>

            <t hangText="Security Parameter Index (SPI):">This field indicates
            the appropriate EKT Key and other parameters for the receiver to use
            when processing the packet. The length
            of this field is 16 bits.  The parameters identified by this field
            are:

           <list
              style="symbols">
            
              <t>The EKT cipher used to process the packet.</t>

              <t>The EKT Key used to process the packet.</t>
                      
              <t>The SRTP Master Salt associated with any Master Key
              encrypted with this EKT Key.</t>
             
            </list>
          
            Together, these data elements are called an EKT parameter set.
            Each distinct EKT parameter set that is
            used MUST be associated with a distinct SPI value to avoid
            ambiguity.
           </t>

	   <t hangText="EKTMsgLength"> All EKT message other that Short EKT Field
	   must have a length as the second from last elements.  This is the length
	   in octets of the full EKT message including this length field and the
	   following message type. </t>
	   
            <t hangText="Message Type"> The last byte is used to indicate the
            type of the Field. This MUST be 2 in the Full EKT Field format and 0
            in Short EKT Field. Future specifications that define new types
            SHOULD use even values until all the even code points are consumed
            to avoid conflicts with pre standards version of EKT that have been
            deployed.  Values less than 64 are mandatory to understand the whole
            EKT field SHOULD be discarded if it contains message
	        type value that
            is less than 64 and is not implemented.  </t>


          </list>
        </t>
        
      </section>

      <section anchor="processing" title="Packet Processing and State Machine">
        
        <t>At any given time, each SRTP/SRTCP source has associated with
        it a single EKT parameter set. This parameter set is used to process all
        outbound packets, and is called the outbound parameter set for that
        SSRC. There may be other EKT parameter sets that are used by other
        SRTP/SRTCP sources in the same session, including other SRTP/SRTCP
        sources on the same endpoint (e.g., one endpoint with voice and video
        might have two EKT parameter sets, or there might be multiple video
        sources on an endpoint each with their own EKT parameter set).  All of
        the received EKT parameter sets SHOULD be stored by all of the
        participants in an SRTP session, for use in processing inbound SRTP and
        SRTCP traffic.</t>

           <t> Either the FullEKTField or ShortEKTField is appended at the tail
        end of all SRTP packets.  </t>
        
        <section anchor="outbound" title="Outbound Processing">

         <t>See <xref target="timing"></xref> which describes when to send an
         EKT packet with a Full EKT Field. If a Full EKT Field is not being
         sent, then a Short EKT Field needs to be sent so the receiver can
         correctly determine how to process the packet. </t>

          <t>When an SRTP packet is to be sent with a Full EKT Field, the EKT
          field for that packet is created as follows, or uses an equivalent set
          of steps.  The creation of the EKT field MUST precede the normal SRTP
          packet processing.  </t>

          <t><list style="numbers">
           
          <t>The Security Parameter Index (SPI) field is set to the value of the
          Security Parameter Index that is associated with the outbound
          parameter set. </t>

         <t>The EKTPlaintext field is computed from the SRTP Master Key, SSRC,
         and ROC fields, as shown in <xref target="EKT"/>.  The ROC, SRTP Master
         Key, and SSRC used in EKT processing SHOULD be the same as the one used
         in the SRTP processing.
         </t>

          <t>The EKTCiphertext field is set to the ciphertext created by
          encrypting the EKTPlaintext with the EKT cipher, using the EKT Key as
          the encryption key. The encryption process is detailed in <xref
          target="cipher"></xref>.
         </t>


         <t> Then the Full EKT Field is formed using the EKT Ciphertext and the
         SPI associated with the EKT Key used above.
        
              <list style="empty"> <t> Note: the value of
              the EKT Ciphertext field is identical in successive packets protected
              by the same KEK and SRTP master key.  This value MAY be cached by an
              SRTP sender to minimize computational effort.  </t></list>
       
         The computed value of the Full EKT Field is written into the packet.
         </t>
         
         </list></t>

         <t> When a packet is sent with the Short EKT Field, the Short EKF Field
         is simply appended to the packet. </t>
         
         
        </section>

        <section anchor="inbound" title="Inbound Processing">
         
          <t> When receiving a packet on a RTP stream where EKT was
          negotiated, the following steps are applied for each
          received packet.</t>

          <t><list style="numbers">
            
           <t> The final byte is checked to determine which EKT format is in
           use.  When an SRTP or SRTCP packet contains a Short EKT Field, the
           Short EKT Field is removed from the packet then normal SRTP or SRTCP
           processing occurs.  If the packet contains a Full EKT Field, then
           processing continues as described below.</t>

           <t>The Security Parameter Index (SPI)
           field is used to find which EKT parameter set should be used when
           processing the packet.  If there is no matching SPI, then the
           verification function MUST return an indication of authentication
           failure, and the steps described below are not performed.
           The EKT
           parameter set contains the EKT Key, EKT Cipher, and SRTP Master
           Salt. </t>

           <t> The EKT Ciphertext authentication is checked and it is decrypted,
           as described in <xref target="cipher"/>, using the EKT Key and EKT
           Cipher found in the previous step.  If the EKT decryption operation
           returns an authentication failure, then the packet processing stops.
           </t>

           <t> The resulting EKT Plaintext is parsed as described in <xref
           target="EKT"/>, to recover the SRTP Master Key, SSRC, and ROC
           fields. The Master Salt that is associated with the EKT Keys used to do
           the description is also retrieved. </t>
                  
           <t> 
           The SRTP Master Key, ROC, and SRTP Master Salt from the previous step
           are saved in a map indexed by the SSRC found in the EKT Plaintext and
           can be used for any future crypto operations for inbound or outbound
           packets with that SSRC. Outbound packets SHOULD continue to use
           the old SRTP Master Key for 250 ms after receipt of the new key.  This gives all
           the receivers in the system time to get the new key before they start
           receiving media encrypted with the new key. </t>
          
            <t>At this point, EKT processing has successfully completed, and the
            normal SRTP or SRTCP processing takes place including replay
            protection.
           
           </t>
          </list>
        </t>

        <section anchor="inbound_impl_notes"
                 title="Implementation Notes for Inbound Processing" >

          <t>The value of the EKT Ciphertext field is identical in
          successive packets protected by the same EKT parameter set
          and the same SRTP master key, and ROC.  This ciphertext
          value MAY be cached by an SRTP receiver to minimize
          computational effort by noting when the SRTP master key is
          unchanged and avoiding repeating the above steps.</t>

          <t> The receiver may want to have a sliding window to retain
          old SRTP master keys (and related context) for some brief
          period of time, so that out of order packets can be
          processed as well as packets sent during the time keys are
          changing. </t>
          
        </section>
        
      </section>
    </section>

    <section anchor="cipher" title="Ciphers">
          
          <t>EKT uses an authenticated cipher to encrypt and authenticate the
          EKT Plaintext. We first specify the interface to the cipher, in order
          to abstract the interface away from the details of that function. We
          then define the cipher that is used in EKT by default. The default
          cipher described in <xref target="DefaultCipher"></xref> MUST be
          implemented, but another cipher that conforms to this interface MAY be
          used, in which case its use MUST be coordinated by external means
          (e.g., key management).</t>

          <t>An EKT cipher consists of an encryption function and a decryption
          function. The encryption function E(K, P) takes the following inputs:
          <list style="symbols">
            
            <t>a secret key K with a length of L bytes, and</t>

            <t>a plaintext value P with a length of M bytes.</t>
            
          </list>

          The encryption function returns a ciphertext value C whose length is N
          bytes, where N may be larger than M.  The decryption function D(K, C) takes
          the following inputs: <list style="symbols">
          
          <t>a secret key K with a length of L bytes, and</t>

          <t>a ciphertext value C with a length of N bytes.</t>

        </list>

        The decryption function returns a plaintext value P that is at
        least M bytes
        long, or returns an indication that the decryption operation failed
        because the ciphertext was invalid (i.e. it was not generated by the
        encryption of plaintext with the key K).
             </t>
          
             <t> These functions have the property that D(K, E(K, P))
             = ( P concatenated with optional padding) for all values
             of K and P.  Each cipher also has a limit T on the number
             of times that it can be used with any fixed key
             value. The EKT Key MUST NOT be used more that T
             times. </t>

             <t>Security requirements for EKT ciphers are discussed in <xref
             target="sec"/>. </t>

          <section anchor="DefaultCipher" title=" Ciphers">
            
            <t> The default EKT Cipher is the Advanced Encryption
            Standard (AES) Key Wrap with Padding <xref
            target="RFC5649"></xref> algorithm.  It requires a
            plaintext length M that is at least one octet, and it
            returns a ciphertext with a length of N = M + (M mod 8) +
            8 octets.  It can be used with key sizes of L = 16, and L
            = 32 octets, and its use with those key sizes is indicated
            as AESKW_128, or AESKW_256, respectively.  The key size
            determines the length of the AES key used by the Key Wrap
            algorithm.  With this cipher, T=2^48. </t>
               
               <texttable anchor="CipherTable" title="EKT Ciphers">
                 <ttcol align='left'>Cipher</ttcol>
                 <ttcol align='right'>L</ttcol>
                 <ttcol align='right'>T</ttcol>
                 <c> AESKW_128 </c><c> 16 </c><c> 2^48 </c> 
                 <c> AESKW_256 </c><c> 32 </c><c> 2^48 </c> 
               </texttable>
               
                 <t>
                   As AES-128 is the mandatory to implement transform in <xref
                   target="RFC3711">SRTP</xref>, AESKW_128 MUST be implemented
                   for EKT and  AESKW_256 (TODO MAY / SHOULD / or MUST) be implemented.</t>
              
          </section>

          <section title="Defining New EKT Ciphers">
            
            <t>Other specifications may extend this document by defining other EKT
            ciphers as described in <xref target="iana"></xref>. This section defines how
            those ciphers interact with this specification.</t>

            <t>An EKT cipher determines how the EKT Ciphertext field is written,
            and how it is processed when it is read. This field is opaque to the
            other aspects of EKT processing. EKT ciphers are free to use this
            field in any way, but they SHOULD NOT use other EKT or SRTP fields
            as an input.  The values of the parameters L, and T MUST be
            defined by each EKT cipher. </t>
            
          </section>
        </section>

        <section anchor="SynchronizingOperation" title="Synchronizing
                                                        Operation">
          
          <t>If a source has its EKT key changed by the key management, it MUST
          also change its SRTP master key, which will cause it to send out a new
          Full EKT Field.  This ensures that if key management thought the EKT
          key needs changing (due to a participant leaving or joining) and
          communicated that in key management to a source, the source will also
          change its SRTP master key, so that traffic can be decrypted only by
          those who know the current EKT key.</t>

        </section>

        <section anchor="srtp" title="Transport">
          
          <t>  EKT
          SHOULD be used over SRTP, and other specification MAY define how to
          use it over SRTCP.  SRTP is preferred because it shares fate with
          transmitted media, because SRTP rekeying can occur without concern for
          RTCP transmission limits, and to avoid SRTCP compound packets with RTP
          translators and mixers. </t>

        </section>

        <section anchor="timing" title="Timing and Reliability Consideration">

         <t>A system using EKT learns the SRTP master keys distributed with Full
         EKT Fields send with the SRTP, rather than with call signaling.  A
         receiver can immediately decrypt an SRTP provided the SRTP packet
         contains a Full EKT Field.</t>
         
          <t>This section describes how to reliably and expediently deliver new
          SRTP master keys to receivers.</t>

          <t>There are three cases to consider.  The first case is a new sender
          joining a session which needs to communicate its SRTP master key to
          all the receivers.  The second case is a sender changing its SRTP
          master key which needs to be communicated to all the receivers.  The
          third case is a new receiver joining a session already in progress
          which needs to know the sender's SRTP master key.</t>

          <t> The three cases are: <list style="hanging">
          
           <t hangText="New sender:"> A new sender SHOULD send a packet containing the Full
          EKT Field as soon as possible, always before or coincident with
          sending its initial SRTP packet.  To accommodate packet loss, it is
          RECOMMENDED that three consecutive packets contain the Full EKT Field
          be transmitted. </t>

           <t hangText="Rekey:"> By sending EKT over SRTP, the rekeying event
          shares fate with the SRTP packets protected with that new
          SRTP master key.  To accommodate packet loss, it is
          RECOMMENDED that three consecutive packets contain the Full
          EKT Field be transmitted. </t>

          <t hangText="New receiver:"> When a new receiver joins a session it does not need
          to communicate its sending SRTP master key (because it is a receiver).
          When a new receiver joins a session the sender is generally unaware of
          the receiver joining the session.  Thus, senders SHOULD periodically
          transmit the Full EKT Field.  That interval depends on how frequently
          new receivers join the session, the acceptable delay before those
          receivers can start processing SRTP packets, and the acceptable
          overhead of sending the Full EKT Field.
          If sending audio and video, the RECOMMENDED frequency is the
          same as the rate of intra coded video frames. If only sending
          audio, the RECOMMENDED frequency is every 100ms. </t>

          </list></t>

        </section>
      </section>

      <section anchor="dtls-srtp-kt" title="Use of EKT with DTLS-SRTP">
        
        <t>This document defines an extension to DTLS-SRTP called SRTP
        EKT Key Transport which enables secure transport of EKT
        keying material from one DTLS-SRTP peer to another.  This allows those
        peers to process EKT keying material in SRTP (or SRTCP) and retrieve the
        embedded SRTP keying material.  This combination of protocols is
        valuable because it combines the advantages of DTLS, which has
        strong
        authentication of the endpoint and flexibility, along with
        allowing secure multiparty RTP with loose coordination and
        efficient communication of per-source keys.</t>

        <section title="DTLS-SRTP Recap">
          
          <t><xref target="RFC5764">DTLS-SRTP</xref> uses an extended DTLS
          exchange between two peers to exchange keying material, algorithms,
          and parameters for SRTP.  The SRTP flow operates over the same
          transport as the DTLS-SRTP exchange (i.e., the same 5-tuple).
          DTLS-SRTP combines the performance and encryption flexibility benefits
          of SRTP with the flexibility and convenience of DTLS-integrated key
          and association management.  DTLS-SRTP can be viewed in two equivalent
          ways: as a new key management method for SRTP, and a new RTP-specific
          data format for DTLS.</t>
        </section>

        <section anchor="dtls-srtp-extensions"
                 title="SRTP EKT Key Transport Extensions to DTLS-SRTP">
          
          <t>This document defines a new TLS negotiated extension
          called "srtp_ekt_key_transport"and a new TLS content type
          called EKTMessage. </t>

            <figure anchor="tls_datastructure"
                    title="Additional TLS Data Structures">
              <preamble>Using the syntax described in <xref
              target="RFC6347">DTLS</xref>, the following
              structures are used:</preamble>

<artwork align="center"><![CDATA[
enum {
  reserved(0),  
  aeskw_128(1),  
  aeskw_256(3),  
} EKTCipherType;  

struct {
  EKTCipherType ekt_ciphers<0..254>;
} SupportedEKTCiphers;

struct {
  EKTCipherType ekt_cipher; 
  uint ekt_key_value<1..256>;  
  uint srtp_master_salt<1..256>;  
  uint16 ekt_spi;  
  uint24 ekt_ttl; 
} EKTkey;  

enum {
  ekt_key(0),
  ekt_key_ack(1),
  ekt_key_error(254),
  (255)
} EKTMessageType;

struct {
  EKTMessageType ekt_message_type;
  select (EKTMessage.ekt_message_type) {
  case ekt_key:
    EKTKey;
  } message;
} EKTMessage;
]]></artwork>
			</figure>

          <t> If a DTLS client includes "srtp_ekt_key_transport" in
          its ClientHello, then a DTLS server that supports this
          extensions will includes "srtp_ekt_key_transport" in its
          ServerHello message. If a DTLS client includes
          "srtp_ekt_key_transport" in its ClientHello, but does not
          receive "srtp_ekt_key_transport" in the ServerHello, the
          DTLS client MUST NOT send DTLS EKTMessage messages.</t>

          <t> When a TLS client sends the "srtp_ekt_key_transport" in
          its ServerHello message, it MUST include a
          SupportedEKTCiphers as the extension_data for the extension
          that contains the EKT ciphers the client is willing to use
          in preference order, with the most preferred version
          first. When the server responds in the
          "srtp_ekt_key_transport" in its ServerHello message, it must
          include a SupportedEKTCiphers list that selects a single EKT
          cipher to use that is selected out of the list provided by
          the client or it returns an empty list to indicate there is
          no EKT cipher that was in the clients list that the server
          is also willing to use. </t>

          <t> The figure above defines the contents for a new TLS
            content type called EKTMessage  which is registered in <xref
            target="iana-tls-content"/>. The EKTMessage above is used
            as the opaque fragment in the TLSPlaintext structure
            defined in Section 6.2.1 of <xref target="RFC5246"></xref>
            and the "srtp_ekt_message" as the content type. The
            "srtp_ekt_message" content type is defined and registered
            in <xref target="iana-tls-ext"/>. </t>

            <t> 
            <list style="hanging">

              <t hangText="ekt_ttl:">The maximum amount of time, in
              seconds, that this ekt_key_value can be used. The
              ekt_key_value in this message MUST NOT be used for
              encrypting or decrypting information after the TTL
              expires.  </t>

            </list>
            </t>

            <t> When the Server wishes to provide a new EKT Key, it can
            send EKTMessage containing an EKTKey with the new key
            information. The client MUST respond with an EKTMessage or
            type ekt_key_ack if the EKTKey was successfully processed
            and stored or ekt_key_error otherwise. </t>

            
            <t>The diagram below shows a message flow of DTLS client and DTLS
            server using the DTLS-SRTP Key Transport extension. </t>

            <figure anchor="tls_handshake_message_flow"
                    title="DTLS/SRTP Message Flow">
              <preamble></preamble>
<artwork align="center"><![CDATA[
Client                                               Server

ClientHello + use_srtp + srtp_ekt_key_trans
                             -------->
                              ServerHello+use_srtp+srtp_ekt_key_trans
                                              Certificate*
                                        ServerKeyExchange*
                                       CertificateRequest*
                             <--------     ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     -------->
                                        [ChangeCipherSpec]
                             <--------            Finished
ekt_key                      <-------- 
ACK                          --------> 
SRTP packets                 <------->      SRTP packets
SRTP packets                 <------->      SRTP packets
ekt_key (rekey)              <-------
ACK                          --------> 
SRTP packets                 <------->      SRTP packets
SRTP packets                 <------->      SRTP packets
]]></artwork>
            </figure>


        </section>

        <section title="Offer/Answer Considerations">

          <t> When using EKT with DTLS-SRTP, the negotiation to use EKT is done
          at the DTLS handshake level and does not change the <xref
          target="RFC3264"></xref> Offer / Answer messaging.
          </t>
          
        </section>
      </section>

      <section title="Sending the DTLS EKT_Key Reliably">

       <t> The DTLS ekt_key is sent using the retransmissions specified
       in Section 4.2.4. of <xref target="RFC6347">DTLS</xref>. </t>
             
      </section>

      <section anchor="sec" title="Security Considerations">
        
        <t>EKT inherits the security properties of the DTLS-SRTP (or other)
        keying it uses.</t>

        <t>With EKT, each SRTP sender and receiver MUST generate distinct SRTP
        master keys. This property avoids any security concern over the re-use
        of keys, by empowering the SRTP layer to create keys on demand. Note
        that the inputs of EKT are the same as for SRTP with key-sharing: a
        single key is provided to protect an entire SRTP session. However, EKT
        remains secure even when SSRC values collide.</t>

        <t> SRTP master keys MUST be randomly generated, and <xref
        target="RFC4086"></xref> offers some guidance about random
        number generation.  SRTP master keys MUST NOT be re-used for
        any other purpose, and SRTP master keys MUST NOT be derived
        from other SRTP master keys. </t>

        <t>The EKT Cipher includes its own authentication/integrity check. For
        an attacker to successfully forge a full EKT packet, it would need to
        defeat the authentication mechanisms of the EKT Cipher authentication
        mechanism.</t>

        <t> The presence of the SSRC in the EKTPlaintext ensures that an
        attacker cannot substitute an EKTCiphertext from one SRTP stream into
        another SRTP stream.  </t>
        
        <t> An attacker who tampers with the bits in FullEKTField can prevent
        the intended receiver of that packet from being able to decrypt it.
        This is a minor denial of service vulnerability.  </t>
  
        <t>An attacker could send packets containing a Full EKT Field, in an
        attempt to consume additional CPU resources of the receiving system by
        causing the receiving system will decrypt the EKT ciphertext and detect
        an authentication failure.
        In some cases, caching the previos values of the Ciphertext as
        described in <xref target="inbound_impl_notes"></xref> helps
        mitigate this issue. </t>

        <t> Each EKT cipher specifies a value T that is the maximum
        number of times a given key can be used. An endpoint MUST NOT
        send more than T Full EKT Field using the same EKTKey. </t>

        <t>The confidentiality, integrity, and authentication of the EKT cipher
        MUST be at least as strong as the SRTP cipher and at least as
        strong as the DTLS-SRTP ciphers. </t>
        
        <t> Part of the EKTPlaintext is known, or easily guessable to an
        attacker.  Thus, the EKT Cipher MUST resist known plaintext attacks.  In
        practice, this requirement does not impose any restrictions on our
        choices, since the ciphers in use provide high security even when much
        plaintext is known.</t>
        
        <t>An EKT cipher MUST resist attacks in which both ciphertexts and
        plaintexts can be adaptively chosen and adversaries that can query both
        the encryption and decryption functions adaptively.</t>

        <t> In some systems, when a member of a conference leaves the
        conferences, the conferences is rekeyed so that member no
        longer has the key.  When changing to a new EKTKey, it is
        possible that the attacker could block the EKTKey message
        getting to a particular endpoint and that endpoint would keep
        sending media encrypted using the old key. To mitigate that
        risk, the lifetime of the EKTKey SHOULD be limited using the
        ekt_ttl. </t>
        
      </section>

       <section anchor="iana" title="IANA Considerations">

         <section anchor="iana-ekt-msg-types" title="EKT Message
                                                     Types">
           
           <t> TODO IANA registry for Message Type. </t>

         </section>
         
         <section anchor="iana-ciphers" title="EKT Ciphers">
           
           <t>  TODO IANA registry EKT ciphers.</t>
           
         </section>
         
         <section anchor="iana-tls-ext" title="TLS Extensions">

           <t> IANA is requested to add "srtp_ekt_key_transport" as an
           new extension name to the "ExtensionType Values" table of
           the "Transport Layer Security (TLS) Extensions" registry
           with a reference to this specification and allocate a value
           of TBD to for this. Note to RFC Editor: TBD will be
           allocated by IANA. </t>

           <t> Considerations for this type of extension are described
           in Section 5 of <xref target="RFC4366"></xref> and requires
           "IETF Consensus". </t>
           
         </section>

         <section anchor="iana-tls-content" title="TLS Content Type">

           <t> IANA is requested to add "srtp_ekt_message" as an new
           descriptions name to the "TLS ContentType Registry" table
           of the "Transport Layer Security (TLS) Extensions" registry
           with a reference to this specification, a DTLS-OK value of
           "Y", and allocate a value of TBD to for this content
           type. Note to RFC Editor: TBD will be allocated by
           IANA. </t>

           <t> This registry was defined in Section 12 of <xref
           target="RFC5246"></xref> and requires "Standards
           Action". </t>
           
         </section>
        
      </section>

      <section title="Acknowledgements">
        
        <t>
        Thank you to Russ Housley provided detailed review and
        significant help with crafting text for this document.
        Thanks to
        David Benham,
        Eddy Lem,
        Felix Wyss,
        Jonathan Lennox,
        Kai Fischer,
        Lakshminath Dondeti,
        Magnus Westerlund,
        Michael Peck,
        Nermeen Ismail,
        Paul Jones,
        Rob Raymond, and
        Yi Cheng
        for fruitful discussions, comments, and contributions to this
        document.</t>

       <t> This draft is a cut down version of draft-ietf-avtcore-srtp-ekt-03
       and much of the text here came from that draft. </t>
       
      </section>
    </middle>

    <back>
      <references title="Normative References">

        &rfc2119;
        &rfc3711;
        &rfc4086;
        &rfc5649;
        &rfc5764;
        &rfc6347; 
        &rfc5246; 
        &rfc5234; 
        
      </references>

      <references title="Informative References">
        
        &rfc3264;
        &rfc4366;
        
      </references>


    </back> </rfc>
